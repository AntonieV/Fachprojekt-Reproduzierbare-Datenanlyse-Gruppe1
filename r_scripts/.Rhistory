library(calibrate)
library(dplyr)
p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
#p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
#matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
#samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
if(any(p_all$target_id != row.names(matr))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}else{
condition_1 <- samples$sample[samples$condition == as.character(factor(samples$condition)[1])]
condition_2 <- samples$sample[samples$condition == as.character(factor(samples$condition)[2])]
samples.cond_1 <- matr[][as.character(samples$sample[condition_1])]
samples.cond_2 <- matr[][as.character(samples$sample[condition_2])]
FoldChange <- rowSums(samples.cond_2)/rowSums(samples.cond_1)
log2FC <- log2(FoldChange)
plot_x <- log2FC   #Definitionsbereich: log2-FoldChange ohne NA-Werte
plot_x[which(is.nan())]=0
plot_x <- plot_x[which(is.nan())]=0
plot_x[which(is.nan(plot_x))]=0
library(MASS)
library(calibrate)
library(dplyr)
p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
#p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
#matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
#samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
if(any(p_all$target_id != row.names(matr))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}else{
condition_1 <- samples$sample[samples$condition == as.character(factor(samples$condition)[1])]
condition_2 <- samples$sample[samples$condition == as.character(factor(samples$condition)[2])]
samples.cond_1 <- matr[][as.character(samples$sample[condition_1])]
samples.cond_2 <- matr[][as.character(samples$sample[condition_2])]
FoldChange <- rowSums(samples.cond_2)/rowSums(samples.cond_1)
log2FC <- log2(FoldChange)
plot_x <- log2FC   #Definitionsbereich: log2-FoldChange ohne NA-Werte
plot_x[which(is.nan(plot_x))] = 0
library(MASS)
library(calibrate)
library(dplyr)
p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
#p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
#matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
#samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
if(any(p_all$target_id != row.names(matr))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}else{
condition_1 <- samples$sample[samples$condition == as.character(factor(samples$condition)[1])]
condition_2 <- samples$sample[samples$condition == as.character(factor(samples$condition)[2])]
samples.cond_1 <- matr[][as.character(samples$sample[condition_1])]
samples.cond_2 <- matr[][as.character(samples$sample[condition_2])]
FoldChange <- rowSums(samples.cond_2)/rowSums(samples.cond_1)
log2FC <- log2(FoldChange)
plot_x <- log2FC   #Definitionsbereich: log2-FoldChange ohne NA-Werte
plot_x[which(is.nan(plot_x))] = 0
library(MASS)
library(calibrate)
library(dplyr)
p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
#p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
#matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
#samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
library(MASS)
library(calibrate)
library(dplyr)
p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
#p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
#matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
#samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
condition_1 <- samples$sample[samples$condition == as.character(factor(samples$condition)[1])]
condition_2 <- samples$sample[samples$condition == as.character(factor(samples$condition)[2])]
samples.cond_1 <- matr[][as.character(samples$sample[condition_1])]
samples.cond_2 <- matr[][as.character(samples$sample[condition_2])]
FoldChange <- rowSums(samples.cond_2)/rowSums(samples.cond_1)
log2FC <- log2(FoldChange)
plot_x <- log2FC   #Definitionsbereich: log2-FoldChange ohne NA-Werte
plot_x[which(is.nan(plot_x))] = 0
library(MASS)
library(calibrate)
library(dplyr)
p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
#p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
#matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
#samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
if(any(p_all$target_id != row.names(matr))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}else{
condition_1 <- samples$sample[samples$condition == as.character(factor(samples$condition)[1])]
condition_2 <- samples$sample[samples$condition == as.character(factor(samples$condition)[2])]
samples.cond_1 <- matr[][as.character(samples$sample[condition_1])]
samples.cond_2 <- matr[][as.character(samples$sample[condition_2])]
FoldChange <- rowSums(samples.cond_2)/rowSums(samples.cond_1)
log2FC <- log2(FoldChange)
plot_x <- log2FC   #Definitionsbereich: log2-FoldChange ohne NA-Werte
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_x[which(is.nan(plot_x))] = Inf
plot_x[which(is.na(plot_x))] = 0
min_x <- min(plot_x[is.finite(plot_x)])
max_x <- max(plot_x[is.finite(plot_x)])
p_val <- p_all$pval
plot_y <- -log10(p_val) #Wertebereich: -log10 der p-Werte
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_y[which(is.nan(plot_y))] = Inf
plot_y[which(is.na(plot_y))] = 0
min_y <- min(plot_y[is.finite(plot_y)])
max_y <- max(plot_y[is.finite(plot_y)])
#Anlegen des Dataframes fuer den Volcano-Plot mit:
#Gen/Target-ID,
#FoldChange(log2),
#p-Werten aus der Sleuth-Analyse und
#den durch Post-Hoc-Tests normaliesierten p-Werten (qval, also Korrektur der
#Alphafehler-Kumulierung beim multiplen Testen) aus der Sleuth-Analyse
volcano.data <- data.frame(GeneID = p_all$target_id, log2FoldChange = plot_x,
pVal = plot_y, PostHoc_pValues = p_all$qval)
# svg(file=snakemake@output[[1]])
# Make a basic volcano plot
with(volcano.data, plot(log2FoldChange, pVal, pch = 20, main = "Volcano-Plot",
xlim = c(min_x, max_x),
ylim = c(min_y, max_y),
xlab = "log2(FoldChange)", ylab = "-log10(p-Values)"))
# Add colored points: red if padj<0.05, orange of log2FC>1, green if both)
with(subset(volcano.data, PostHoc_pValues<.05 ), points(log2FoldChange, pVal, pch=20, col="red"))
with(subset(volcano.data, abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="orange"))
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="green"))
# Label points with the textxy function from the calibrate plot
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), textxy(log2FoldChange, pVal, labs=GeneID, cex=.8))
# dev.off()
}
library(MASS)
library(calibrate)
library(dplyr)
p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
#p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
#matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
#samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
if(any(p_all$target_id != row.names(matr))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}else{
condition_1 <- samples$sample[samples$condition == as.character(factor(samples$condition)[1])]
condition_2 <- samples$sample[samples$condition == as.character(factor(samples$condition)[2])]
samples.cond_1 <- matr[][as.character(samples$sample[condition_1])]
samples.cond_2 <- matr[][as.character(samples$sample[condition_2])]
FoldChange <- rowSums(samples.cond_2)/rowSums(samples.cond_1)
log2FC <- log2(FoldChange)
plot_x <- log2FC   #Definitionsbereich: log2-FoldChange ohne NA-Werte
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_x[which(is.nan(plot_x))] = Inf
plot_x[which(is.na(plot_x))] = 0
min_x <- min(plot_x[is.finite(plot_x)])
max_x <- max(plot_x[is.finite(plot_x)])
p_val <- p_all$pval
plot_y <- -log10(p_val) #Wertebereich: -log10 der p-Werte
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_y[which(is.nan(plot_y))] = Inf
plot_y[which(is.na(plot_y))] = 0
min_y <- min(abs(plot_y[is.finite(plot_y)]))
max_y <- max(plot_y[is.finite(plot_y)])
#Anlegen des Dataframes fuer den Volcano-Plot mit:
#Gen/Target-ID,
#FoldChange(log2),
#p-Werten aus der Sleuth-Analyse und
#den durch Post-Hoc-Tests normaliesierten p-Werten (qval, also Korrektur der
#Alphafehler-Kumulierung beim multiplen Testen) aus der Sleuth-Analyse
volcano.data <- data.frame(GeneID = p_all$target_id, log2FoldChange = plot_x,
pVal = plot_y, PostHoc_pValues = p_all$qval)
# svg(file=snakemake@output[[1]])
# Make a basic volcano plot
with(volcano.data, plot(log2FoldChange, pVal, pch = 20, main = "Volcano-Plot",
xlim = c(min_x, max_x),
ylim = c(min_y, max_y),
xlab = "log2(FoldChange)", ylab = "-log10(p-Values)"))
# Add colored points: red if padj<0.05, orange of log2FC>1, green if both)
with(subset(volcano.data, PostHoc_pValues<.05 ), points(log2FoldChange, pVal, pch=20, col="red"))
with(subset(volcano.data, abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="orange"))
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="green"))
# Label points with the textxy function from the calibrate plot
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), textxy(log2FoldChange, pVal, labs=GeneID, cex=.8))
# dev.off()
}
View(volcano.data)
summary(volcano.data$pVal)
#Wertebereich: -log10 der p-Werte
p_val <- p_all$pval
library(MASS)
library(calibrate)
library(dplyr)
p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
#p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
#matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
#samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
if(any(p_all$target_id != row.names(matr))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}else{
condition_1 <- samples$sample[samples$condition == as.character(factor(samples$condition)[1])]
condition_2 <- samples$sample[samples$condition == as.character(factor(samples$condition)[2])]
samples.cond_1 <- matr[][as.character(samples$sample[condition_1])]
samples.cond_2 <- matr[][as.character(samples$sample[condition_2])]
#Definitionsbereich: log2-FoldChange
FoldChange <- rowSums(samples.cond_2)/rowSums(samples.cond_1)
log2FC <- log2(FoldChange)
plot_x <- log2FC
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_x[which(is.nan(plot_x))] = Inf
plot_x[which(is.na(plot_x))] = 0
min_x <- min(plot_x[is.finite(plot_x)])
max_x <- max(plot_x[is.finite(plot_x)])
#Wertebereich: -log10 der p-Werte
p_val <- p_all$pval
plot_y <- -log10(p_val)
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_y[which(is.nan(plot_y))] = Inf
plot_y[which(is.na(plot_y))] = 0
min_y <- min(abs(plot_y[is.finite(plot_y)]))
max_y <- max(plot_y[is.finite(plot_y)])
#Anlegen des Dataframes fuer den Volcano-Plot mit:
#Gen/Target-ID,
#FoldChange(log2),
#p-Werten aus der Sleuth-Analyse und
#den durch Post-Hoc-Tests normaliesierten p-Werten (qval, also Korrektur der
#Alphafehler-Kumulierung beim multiplen Testen) aus der Sleuth-Analyse
volcano.data <- data.frame(GeneID = p_all$target_id, log2FoldChange = plot_x,
pVal = plot_y, PostHoc_pValues = p_all$qval)
# svg(file=snakemake@output[[1]])
# Make a basic volcano plot
with(volcano.data, plot(log2FoldChange, pVal, pch = 20, main = "Volcano-Plot",
xlim = c(min_x, max_x),
ylim = c(min_y, max_y),
xlab = "log2(FoldChange)", ylab = "-log10(p-Values)"))
# Add colored points: red if padj<0.05, orange of log2FC>1, green if both)
with(subset(volcano.data, PostHoc_pValues<.05 ), points(log2FoldChange, pVal, pch=20, col="red"))
with(subset(volcano.data, abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="orange"))
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="green"))
# Label points with the textxy function from the calibrate plot
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), textxy(log2FoldChange, pVal, labs=GeneID, cex=.8))
# dev.off()
}
library(MASS)
library(calibrate)
library(dplyr)
p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
#p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
#matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
#samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
if(any(p_all$target_id != row.names(matr))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}else{
condition_1 <- samples$sample[samples$condition == as.character(factor(samples$condition)[1])]
condition_2 <- samples$sample[samples$condition == as.character(factor(samples$condition)[2])]
samples.cond_1 <- matr[][as.character(samples$sample[condition_1])]
samples.cond_2 <- matr[][as.character(samples$sample[condition_2])]
#Definitionsbereich: log2-FoldChange
FoldChange <- rowSums(samples.cond_2)/rowSums(samples.cond_1)
log2FC <- log2(FoldChange)
plot_x <- log2FC
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_x[which(is.nan(plot_x))] = Inf
plot_x[which(is.na(plot_x))] = 0
min_x <- min(plot_x[is.finite(plot_x)])
max_x <- max(plot_x[is.finite(plot_x)])
#Wertebereich: -log10 der p-Werte
p_val <- p_all$pval
plot_y <- -log10(p_val)
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_y[which(is.nan(plot_y))] = Inf
plot_y[which(is.na(plot_y))] = 0
min_y <- min(abs(plot_y[is.finite(plot_y)]))
max_y <- max(plot_y[is.finite(plot_y)])
#Anlegen des Dataframes fuer den Volcano-Plot mit:
#Gen/Target-ID,
#FoldChange(log2),
#p-Werten aus der Sleuth-Analyse und
#den durch Post-Hoc-Tests normaliesierten p-Werten (qval, also Korrektur der
#Alphafehler-Kumulierung beim multiplen Testen) aus der Sleuth-Analyse
volcano.data <- data.frame(GeneID = p_all$target_id, log2FoldChange = plot_x,
pVal = plot_y, PostHoc_pValues = p_all$qval)
# svg(file=snakemake@output[[1]])
# Make a basic volcano plot
with(volcano.data, plot(log2FoldChange, pVal, pch = 20, main = "Volcano-Plot",
xlim = c(min_x, max_x),
ylim = c(min_y, max_y),
xlab = "log2(FoldChange)", ylab = "-log10(p-Values)"))
# Add colored points: red if padj<0.05, orange of log2FC>1, green if both)
with(subset(volcano.data, PostHoc_pValues<.05 ), points(log2FoldChange, pVal, pch=20, col="red"))
with(subset(volcano.data, abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="orange"))
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="green"))
# Label points with the textxy function from the calibrate plot
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), textxy(log2FoldChange, pVal, labs=GeneID, cex=.8))
# dev.off()
}
library(MASS)
library(calibrate)
library(dplyr)
#p_all <- read.table("../sleuth/p-values_all_transcripts.csv", header=TRUE)
#matr <- read.table("../sleuth/sleuth_matrix.csv", header=TRUE)
#samples <- read.table("../table_for_reads.csv", header=TRUE, stringsAsFactors = TRUE)
p_all <- read.table(snakemake@input[["pval"]], header=TRUE)
matr <- read.table(snakemake@input[["matrix"]], header=TRUE)
samples <- read.table(snakemake@input[["samples"]], header=TRUE, stringsAsFactors = TRUE)
#p_all ist nach pval sortiert, wird nun wie Matrix nach Gen-ID angeordnet:
p_all <- dplyr::arrange(p_all, target_id)
if(any(p_all$target_id != row.names(matr))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}else{
condition_1 <- samples$sample[samples$condition == as.character(factor(samples$condition)[1])]
condition_2 <- samples$sample[samples$condition == as.character(factor(samples$condition)[2])]
samples.cond_1 <- matr[][as.character(samples$sample[condition_1])]
samples.cond_2 <- matr[][as.character(samples$sample[condition_2])]
#Definitionsbereich: log2-FoldChange
FoldChange <- rowSums(samples.cond_2)/rowSums(samples.cond_1)
log2FC <- log2(FoldChange)
plot_x <- log2FC
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_x[which(is.nan(plot_x))] = Inf
plot_x[which(is.na(plot_x))] = 0
min_x <- min(plot_x[is.finite(plot_x)])
max_x <- max(plot_x[is.finite(plot_x)])
#Wertebereich: -log10 der p-Werte
p_val <- p_all$pval
plot_y <- -log10(p_val)
#ungueltige Werte anpassen, Intervall des Definitionsbereichs bestimmen
plot_y[which(is.nan(plot_y))] = Inf
plot_y[which(is.na(plot_y))] = 0
min_y <- min(abs(plot_y[is.finite(plot_y)]))
max_y <- max(plot_y[is.finite(plot_y)])
#Anlegen des Dataframes fuer den Volcano-Plot mit:
#Gen/Target-ID,
#FoldChange(log2),
#p-Werten aus der Sleuth-Analyse und
#den durch Post-Hoc-Tests normaliesierten p-Werten (qval, also Korrektur der
#Alphafehler-Kumulierung beim multiplen Testen) aus der Sleuth-Analyse
volcano.data <- data.frame(GeneID = p_all$target_id, log2FoldChange = plot_x,
pVal = plot_y, PostHoc_pValues = p_all$qval)
svg(file=snakemake@output[[1]])
#Volcano-Plot anlegen
with(volcano.data, plot(log2FoldChange, pVal, pch = 20, main = "Volcano-Plot",
xlim = c(min_x, max_x),
ylim = c(min_y, max_y),
xlab = "log2(FoldChange)", ylab = "-log10(p-Values)"))
#Farbgebung: rot := p-Wert(nach Posthoc-Test) < 0.05, orange := log2FoldChange > 1,
#            gruen := signifikant(p < 0.05), log2FoldChange > 1
with(subset(volcano.data, PostHoc_pValues<.05 ), points(log2FoldChange, pVal, pch=20, col="red"))
with(subset(volcano.data, abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="orange"))
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), points(log2FoldChange, pVal, pch=20, col="green"))
#Datenpunkte anpassen
with(subset(volcano.data, PostHoc_pValues<.05 & abs(log2FoldChange)>1), textxy(log2FoldChange, pVal, labs=GeneID, cex=.8))
dev.off()
}
library(ComplexHeatmap)
#library(rsvg)
library(circlize)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
path.p_all <- "../sleuth/p-values_all_transcripts.csv"
write("\n", file = path.dist, append = TRUE)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
matr.so <- read.table(path.matr)
genes <- read.table(path.p_all)
View(matr.so)
#Sortieren Sleuth-Resultaten nach target_id
genes <- dplyr::arrange(genes, target_id)
View(genes)
View(genes)
library(ComplexHeatmap)
#library(rsvg)
library(circlize)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
path.p_all <- "../sleuth/p-values_all_transcripts.csv"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
#path.p_all <- snakemake@input[["p_all"]]
write("\n", file = path.dist, append = TRUE)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
matr.so <- read.table(path.matr)
genes <- read.table(path.p_all)
if(any(genes$target_id != row.names(matr.so))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}
library(ComplexHeatmap)
#library(rsvg)
library(circlize)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
path.p_all <- "../sleuth/p-values_all_transcripts.csv"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
#path.p_all <- snakemake@input[["p_all"]]
write("\n", file = path.dist, append = TRUE)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
matr.so <- read.table(path.matr)
genes <- read.table(path.p_all)
#Sortieren Sleuth-Resultaten nach target_id
genes <- dplyr::arrange(genes, target_id)
if(any(genes$target_id != row.names(matr.so))){
stop("Die Datenmatrix mit der Anzahl der Counts und der Datensatz
der Signifikanzanalyse aus Sluth sind verschieden!")
quit(status = 1, runLast = FALSE)
}
#Ersetzen der target_id durch Gen-Namen
row.names(matr.so) <- genes$ext_gene
#Ersetzen der target_id durch Gen-Namen
row.names(matr.so) = genes$ext_gene
genes$ext_gene
#Ersetzen der target_id durch Gen-Namen
rownames(matr.so) = genes$ext_gene
View(genes$ext_gene)
#Ersetzen der target_id durch Gen-Namen
rownames(matr.so) = genes$ens_gene
#Ersetzen der target_id durch Gen-Namen
dimnames(matr.so) <- list(genes$ext_gene, colnames(matr.so))
#Ersetzen der target_id durch Gen-Namen
dimnames(matr.so) <- list(as.character(genes$ext_gene), colnames(matr.so))
rownames(matr.so) = as.character(genes$ext_gene)
rownames(matr.so) = make.names(genes$ext_gene, unique = TRUE)
View(matr.so)
library(ComplexHeatmap)
#library(rsvg)
library(circlize)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
path.p_all <- "../sleuth/p-values_all_transcripts.csv"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
#path.p_all <- snakemake@input[["p_all"]]
write("\n", file = path.dist, append = TRUE)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
matr.so <- read.table(path.matr)
genes <- read.table(path.p_all)
#Sortieren Sleuth-Resultaten nach target_id
genes <- dplyr::arrange(genes, target_id)
#Ersetzen der target_id durch Gen-Namen
rownames(matr.so) = make.names(genes$ext_gene, unique = TRUE)
#NA-Zeilen entfernen
matr.so <- na.omit(matr.so)
#Null-Zeilen entfernen
matr.so <- subset.matrix(matr.so, rowSums(matr.so)!=0)
#Bestimmung von Median(.5-Quantil) und der Quartile fuer die Faerbung der Heatmap
so.min <- min(matr.so)
so.quantiles <- rowMeans(apply(matr.so, 2, quantile, probs = c(.25, .5, .75)))
Heatmap(matr.so,
name = "normalized\nestimated\ncounts",
column_title = "Samples",
column_names_side = "top",
row_title = "Transcripts",
row_names_side = "right",
row_dend_side = "left",
col = colorRamp2(c(so.min, so.quantiles), c("darkgreen", "green", "darkred", "red")),
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_distance_rows = dist)
View(matr.so)
