file.path()
file.path(*)
file.path()
###################### Installation ##########################
install.packages("Rtools 3.5")
source("http://bioconductor.org/biocLite.R") #insall rhdf5
biocLite("rhdf5")
###################### Installation ##########################
install.packages("Rtools 3.5")
source("http://bioconductor.org/biocLite.R") #insall rhdf5
biocLite("rhdf5")
install.packages("devtools")  #package devtools
devtools::install_github("pachterlab/sleuth")  #install sleuth
###################### Installation ##########################
###sollte schon ueber das env installiert werden####
install.packages("Rtools 3.5")
source("http://bioconductor.org/biocLite.R") #insall rhdf5
biocLite("rhdf5")
install.packages("devtools")  #package devtools
devtools::install_github("pachterlab/sleuth")  #install sleuth
##############################################################
#Sleuth starten:
suppressMessages({
library("sleuth")
})
#Vorbereitungen:
#Verzeichnis-Pfad speichern, in dem die Kallisto-results liegen:
#sample_id <- dir(file.path("...", "results"))  #hier Pfad zu den Kallisto-results angeben
#Betrachten der in diesem Verzeichnis vorhandenen Kallisto-Dateien:
#sample_id
#Listen mit den Pfaden zu den einzelnen Kallisto-Dateien anlegen:
#kal_dirs <- file.path("...", "results", sample_id, "kallisto")  #hier Pfad zu den Kallisto-results angeben
kal_dirs <- snakemake@input[[]]
###################### Installation ##########################
###sollte schon ueber das env installiert werden####
#install.packages("Rtools 3.5")
#source("http://bioconductor.org/biocLite.R") #insall rhdf5
biocLite("rhdf5")
###################### Installation ##########################
###sollte schon ueber das env installiert werden####
#install.packages("Rtools 3.5")
#source("http://bioconductor.org/biocLite.R") #insall rhdf5
biocLite("rhdf5")
#Sleuth starten:
suppressMessages({
library("sleuth")
})
#Vorbereitungen:
#Verzeichnis-Pfad speichern, in dem die Kallisto-results liegen:
#sample_id <- dir(file.path("...", "results"))  #hier Pfad zu den Kallisto-results angeben
#Betrachten der in diesem Verzeichnis vorhandenen Kallisto-Dateien:
#sample_id
#Listen mit den Pfaden zu den einzelnen Kallisto-Dateien anlegen:
#kal_dirs <- file.path("...", "results", sample_id, "kallisto")  #hier Pfad zu den Kallisto-results angeben
kal_dirs <- snakemake@input[[]]
x <- data.frame(a = I("a \" quote"), b = pi)
write.csv(x, file = "../example.csv", row.names = FALSE)
#BiocManager::install("gage", version = "3.8")
x <- data.frame(a = I("a \" quote"), b = pi)
write.csv(x, file = "../example.csv", row.names = FALSE)
#library("gage")
##############################################################
######### Installation Bioconductor - ComplexHeatmap #########
#if (!requireNamespace("BiocManager"))
#  install.packages("BiocManager")
#BiocManager::install()
## try http:// if https:// URLs are not supported
#source("https://bioconductor.org/biocLite.R")
#biocLite("ComplexHeatmap")
##############################################################
library(ComplexHeatmap)
library(rsvg)
library(circlize)
#Input zum direkten Testen ohne Workflow
#path.matr <- "../sleuth/sleuth_matrix.csv"
#path.dist <- "../clustering_distance.txt"
#Snakemake-Input
path.matr <- snakemake@input[["matrix"]]
path.dist <- snakemake@input[["dist"]]
write("\n", file = path.dist, append = TRUE)
matr.so <- read.table(path.matr)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
##############################################################
######### Installation Bioconductor - ComplexHeatmap #########
#if (!requireNamespace("BiocManager"))
#  install.packages("BiocManager")
#BiocManager::install()
## try http:// if https:// URLs are not supported
#source("https://bioconductor.org/biocLite.R")
#biocLite("ComplexHeatmap")
##############################################################
library(ComplexHeatmap)
library(rsvg)
library(circlize)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
write("\n", file = path.dist, append = TRUE)
matr.so <- read.table(path.matr)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
#NA-Zeilen entfernen
View(matr.so)
##############################################################
######### Installation Bioconductor - ComplexHeatmap #########
#if (!requireNamespace("BiocManager"))
#  install.packages("BiocManager")
#BiocManager::install()
## try http:// if https:// URLs are not supported
#source("https://bioconductor.org/biocLite.R")
#biocLite("ComplexHeatmap")
#install.packages("Cairo")
##############################################################
library(ComplexHeatmap)
library(rsvg)
library(circlize)
library(Cairo)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
write("\n", file = path.dist, append = TRUE)
matr.so <- read.table(path.matr)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
#NA-Zeilen entfernen
matr.so <- na.omit(matr.so)
#Null-Zeilen entfernen
matr.so <- subset.matrix(matr.so, rowSums(matr.so)!=0)
#Heatmap(matr.notnull, clustering_distance_rows = "canberra")
#matr.med <- median(apply(matr.notnull, 2, median))
#matr.mean <- mean(apply(matr.notnull, 2, mean))
#matr.range <- apply(matr.notnull, 2, range)
#matr.stdev <- mean(apply(matr.notnull, 2, sd))
#Bestimmung von Median(.5-Quantil) und der Quartile fuer die Faerbung der Heatmap
so.min <- min(matr.so)
so.quantiles <- rowMeans(apply(matr.so, 2, quantile, probs = c(.25, .5, .75)))
#Heatmap wird aufgebaut
Cairo(file="../plots/heatmap.svg",
type="svg")
#units="in",
#width=5,
#height=4,
#pointsize=12,
#dpi=72)
#svg(filename = "../plots/heatmap.svg")
Heatmap(matr.so,
name = "normalized\nestimated\ncounts",
column_title = "Samples",
column_names_side = "top",
row_title = "Transcripts",
row_names_side = "right",
row_dend_side = "left",
col = colorRamp2(c(so.min, so.quantiles), c("darkgreen", "green", "darkred", "red")),
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_distance_rows = dist)
dev.off()
##############################################################
######### Installation Bioconductor - ComplexHeatmap #########
#if (!requireNamespace("BiocManager"))
#  install.packages("BiocManager")
#BiocManager::install()
## try http:// if https:// URLs are not supported
#source("https://bioconductor.org/biocLite.R")
#biocLite("ComplexHeatmap")
#install.packages("Cairo")
##############################################################
library(ComplexHeatmap)
library(rsvg)
library(circlize)
library(Cairo)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
write("\n", file = path.dist, append = TRUE)
matr.so <- read.table(path.matr)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
#NA-Zeilen entfernen
matr.so <- na.omit(matr.so)
#Null-Zeilen entfernen
matr.so <- subset.matrix(matr.so, rowSums(matr.so)!=0)
#Heatmap(matr.notnull, clustering_distance_rows = "canberra")
#matr.med <- median(apply(matr.notnull, 2, median))
#matr.mean <- mean(apply(matr.notnull, 2, mean))
#matr.range <- apply(matr.notnull, 2, range)
#matr.stdev <- mean(apply(matr.notnull, 2, sd))
#Bestimmung von Median(.5-Quantil) und der Quartile fuer die Faerbung der Heatmap
so.min <- min(matr.so)
so.quantiles <- rowMeans(apply(matr.so, 2, quantile, probs = c(.25, .5, .75)))
#Heatmap wird aufgebaut
#Cairo(file="../plots/heatmap.svg",
#      type="svg")
#units="in",
#width=5,
#height=4,
#pointsize=12,
#dpi=72)
#svg(filename = "../plots/heatmap.svg")
x <- Heatmap(matr.so,
name = "normalized\nestimated\ncounts",
column_title = "Samples",
column_names_side = "top",
row_title = "Transcripts",
row_names_side = "right",
row_dend_side = "left",
col = colorRamp2(c(so.min, so.quantiles), c("darkgreen", "green", "darkred", "red")),
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_distance_rows = dist)
write.table(x, file = "../plots/heatmap.svg")
#dev.off()
x
show(x)
##############################################################
######### Installation Bioconductor - ComplexHeatmap #########
#if (!requireNamespace("BiocManager"))
#  install.packages("BiocManager")
#BiocManager::install()
## try http:// if https:// URLs are not supported
#source("https://bioconductor.org/biocLite.R")
#biocLite("ComplexHeatmap")
#install.packages("Cairo")
##############################################################
library(ComplexHeatmap)
library(rsvg)
library(circlize)
library(Cairo)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
write("\n", file = path.dist, append = TRUE)
matr.so <- read.table(path.matr)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
#NA-Zeilen entfernen
matr.so <- na.omit(matr.so)
#Null-Zeilen entfernen
matr.so <- subset.matrix(matr.so, rowSums(matr.so)!=0)
#Heatmap(matr.notnull, clustering_distance_rows = "canberra")
#matr.med <- median(apply(matr.notnull, 2, median))
#matr.mean <- mean(apply(matr.notnull, 2, mean))
#matr.range <- apply(matr.notnull, 2, range)
#matr.stdev <- mean(apply(matr.notnull, 2, sd))
#Bestimmung von Median(.5-Quantil) und der Quartile fuer die Faerbung der Heatmap
so.min <- min(matr.so)
so.quantiles <- rowMeans(apply(matr.so, 2, quantile, probs = c(.25, .5, .75)))
#Heatmap wird aufgebaut
#Cairo(file="../plots/heatmap.svg",
#      type="svg")
#units="in",
#width=5,
#height=4,
#pointsize=12,
#dpi=72)
#svg(filename = "../plots/heatmap.svg")
Heatmap(matr.so,
name = "normalized\nestimated\ncounts",
column_title = "Samples",
column_names_side = "top",
row_title = "Transcripts",
row_names_side = "right",
row_dend_side = "left",
col = colorRamp2(c(so.min, so.quantiles), c("darkgreen", "green", "darkred", "red")),
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_distance_rows = dist)
write.table("test", file = "../plots/heatmap.svg", sep = "\t")
#dev.off()
install.packages("svglite")
## try http:// if https:// URLs are not supported
#source("https://bioconductor.org/biocLite.R")
#biocLite("ComplexHeatmap")
install.packages("svglite")
##############################################################
######### Installation Bioconductor - ComplexHeatmap #########
#if (!requireNamespace("BiocManager"))
#  install.packages("BiocManager")
#BiocManager::install()
## try http:// if https:// URLs are not supported
#source("https://bioconductor.org/biocLite.R")
#biocLite("ComplexHeatmap")
#install.packages("Cairo")
##############################################################
library(ComplexHeatmap)
library(rsvg)
library(circlize)
library(Cairo)
library(svglite)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
write("\n", file = path.dist, append = TRUE)
matr.so <- read.table(path.matr)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
#NA-Zeilen entfernen
matr.so <- na.omit(matr.so)
#Null-Zeilen entfernen
matr.so <- subset.matrix(matr.so, rowSums(matr.so)!=0)
#Heatmap(matr.notnull, clustering_distance_rows = "canberra")
#matr.med <- median(apply(matr.notnull, 2, median))
#matr.mean <- mean(apply(matr.notnull, 2, mean))
#matr.range <- apply(matr.notnull, 2, range)
#matr.stdev <- mean(apply(matr.notnull, 2, sd))
#Bestimmung von Median(.5-Quantil) und der Quartile fuer die Faerbung der Heatmap
so.min <- min(matr.so)
so.quantiles <- rowMeans(apply(matr.so, 2, quantile, probs = c(.25, .5, .75)))
#Heatmap wird aufgebaut
Cairo(file="../plots/heatmap.svg", type="svg")
#CairoSVG(file="../plots/heatmap.svg")
#units="in",
#width=5,
#height=4,
#pointsize=12,
#dpi=72)
#svg(filename = "../plots/heatmap.svg")
#svglite("../plots/heatmap.svg")
Heatmap(matr.so,
name = "normalized\nestimated\ncounts",
column_title = "Samples",
column_names_side = "top",
row_title = "Transcripts",
row_names_side = "right",
row_dend_side = "left",
col = colorRamp2(c(so.min, so.quantiles), c("darkgreen", "green", "darkred", "red")),
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_distance_rows = dist)
dev.off()
##############################################################
######### Installation Bioconductor - ComplexHeatmap #########
#if (!requireNamespace("BiocManager"))
#  install.packages("BiocManager")
#BiocManager::install()
## try http:// if https:// URLs are not supported
#source("https://bioconductor.org/biocLite.R")
#biocLite("ComplexHeatmap")
#install.packages("Cairo")
##############################################################
library(ComplexHeatmap)
library(rsvg)
library(circlize)
library(cairo)
library(svglite)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
write("\n", file = path.dist, append = TRUE)
matr.so <- read.table(path.matr)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
#NA-Zeilen entfernen
matr.so <- na.omit(matr.so)
#Null-Zeilen entfernen
matr.so <- subset.matrix(matr.so, rowSums(matr.so)!=0)
#Heatmap(matr.notnull, clustering_distance_rows = "canberra")
#matr.med <- median(apply(matr.notnull, 2, median))
#matr.mean <- mean(apply(matr.notnull, 2, mean))
#matr.range <- apply(matr.notnull, 2, range)
#matr.stdev <- mean(apply(matr.notnull, 2, sd))
#Bestimmung von Median(.5-Quantil) und der Quartile fuer die Faerbung der Heatmap
so.min <- min(matr.so)
so.quantiles <- rowMeans(apply(matr.so, 2, quantile, probs = c(.25, .5, .75)))
#Heatmap wird aufgebaut
#Cairo(file="../plots/heatmap.svg", type="svg")
CairoSVG(file="../plots/heatmap.svg")
#units="in",
#width=5,
#height=4,
#pointsize=12,
#dpi=72)
#svg(filename = "../plots/heatmap.svg")
#svglite("../plots/heatmap.svg")
Heatmap(matr.so,
name = "normalized\nestimated\ncounts",
column_title = "Samples",
column_names_side = "top",
row_title = "Transcripts",
row_names_side = "right",
row_dend_side = "left",
col = colorRamp2(c(so.min, so.quantiles), c("darkgreen", "green", "darkred", "red")),
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_distance_rows = dist)
dev.off()
##############################################################
######### Installation Bioconductor - ComplexHeatmap #########
#if (!requireNamespace("BiocManager"))
#  install.packages("BiocManager")
#BiocManager::install()
## try http:// if https:// URLs are not supported
#source("https://bioconductor.org/biocLite.R")
#biocLite("ComplexHeatmap")
#install.packages("Cairo")
##############################################################
library(ComplexHeatmap)
library(rsvg)
library(circlize)
library(cairo)
library(svglite)
#Input zum direkten Testen ohne Workflow
path.matr <- "../sleuth/sleuth_matrix.csv"
path.dist <- "../clustering_distance.txt"
#Snakemake-Input
#path.matr <- snakemake@input[["matrix"]]
#path.dist <- snakemake@input[["dist"]]
write("\n", file = path.dist, append = TRUE)
matr.so <- read.table(path.matr)
dist <- gsub("[[:space:]]", "", unlist(read.table(path.dist, stringsAsFactors = FALSE)))
#NA-Zeilen entfernen
matr.so <- na.omit(matr.so)
#Null-Zeilen entfernen
matr.so <- subset.matrix(matr.so, rowSums(matr.so)!=0)
#Heatmap(matr.notnull, clustering_distance_rows = "canberra")
#matr.med <- median(apply(matr.notnull, 2, median))
#matr.mean <- mean(apply(matr.notnull, 2, mean))
#matr.range <- apply(matr.notnull, 2, range)
#matr.stdev <- mean(apply(matr.notnull, 2, sd))
#Bestimmung von Median(.5-Quantil) und der Quartile fuer die Faerbung der Heatmap
so.min <- min(matr.so)
so.quantiles <- rowMeans(apply(matr.so, 2, quantile, probs = c(.25, .5, .75)))
#Heatmap wird aufgebaut
#Cairo(file="../plots/heatmap.svg", type="svg")
#CairoSVG(file="../plots/heatmap.svg")
#units="in",
#width=5,
#height=4,
#pointsize=12,
#dpi=72)
svg(filename = "../plots/heatmap.svg")
#svglite("../plots/heatmap.svg")
Heatmap(matr.so,
name = "normalized\nestimated\ncounts",
column_title = "Samples",
column_names_side = "top",
row_title = "Transcripts",
row_names_side = "right",
row_dend_side = "left",
col = colorRamp2(c(so.min, so.quantiles), c("darkgreen", "green", "darkred", "red")),
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_distance_rows = dist)
dev.off()
